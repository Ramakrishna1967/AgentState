<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>AgentStack ‚Äî Architecture Flowcharts</title>
<script src="https://cdn.jsdelivr.net/npm/mermaid@11/dist/mermaid.min.js"></script>
<script>mermaid.initialize({startOnLoad:true,theme:'dark',themeVariables:{darkMode:true,background:'#0d1117',primaryColor:'#1f6feb',primaryTextColor:'#e6edf3',lineColor:'#58a6ff',secondaryColor:'#161b22',tertiaryColor:'#21262d'}});</script>
<style>
*{margin:0;padding:0;box-sizing:border-box}
body{background:#0d1117;color:#e6edf3;font-family:'Segoe UI',system-ui,sans-serif;padding:40px 60px}
h1{text-align:center;font-size:2.4rem;margin-bottom:10px;background:linear-gradient(135deg,#58a6ff,#bc8cff);-webkit-background-clip:text;-webkit-text-fill-color:transparent}
.subtitle{text-align:center;color:#8b949e;font-size:1rem;margin-bottom:50px}
.diagram-section{background:#161b22;border:1px solid #30363d;border-radius:16px;padding:35px;margin-bottom:40px}
.diagram-section h2{color:#58a6ff;font-size:1.5rem;margin-bottom:6px}
.diagram-section p{color:#8b949e;font-size:0.9rem;margin-bottom:25px;border-left:3px solid #1f6feb;padding-left:12px}
.mermaid{display:flex;justify-content:center}
.mermaid svg{max-width:100%!important}
.badge{display:inline-block;background:#1f6feb;color:#fff;padding:3px 10px;border-radius:20px;font-size:0.75rem;margin-right:8px;vertical-align:middle}
</style>
</head>
<body>

<h1>üîç AgentStack Architecture</h1>
<p class="subtitle">AI Agent Observability Platform ‚Äî 8 High-Level Flowcharts</p>

<!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
<div class="diagram-section">
<h2><span class="badge">1</span> The Big Picture ‚Äî How AgentStack Works</h2>
<p>The complete journey: Developer writes agent ‚Üí SDK captures everything ‚Üí Dashboard shows it all</p>
<pre class="mermaid">
graph TD
    A[Developer Writes AI Agent] -->|Adds one line: @observe| B[AgentStack SDK Activates]
    B -->|Agent runs normally| C{Agent Makes Decisions}
    C -->|Decision 1| D[Calls LLM - GPT4 / Claude]
    C -->|Decision 2| E[Uses a Tool - Search / DB]
    C -->|Decision 3| F[Reads Memory - Past Context]
    D -->|SDK silently records| G[Every Step Captured as a Span]
    E -->|SDK silently records| G
    F -->|SDK silently records| G
    G -->|Batched every 5 seconds| H[Sent to AgentStack Server]
    H -->|Stored in database| I[ClickHouse Time-Series DB]
    I -->|Queried by| J[FastAPI Backend]
    J -->|Served to| K[React Dashboard]
    K -->|Developer sees| L((Full Timeline of Agent Thought Process))
    L -->|Finds the bug| M[Developer Fixes Agent]
    M -->|Runs again| A
</pre>
</div>

<!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
<div class="diagram-section">
<h2><span class="badge">2</span> Data Pipeline ‚Äî From Agent to Dashboard</h2>
<p>Every span travels through 5 layers before reaching the developer's screen</p>
<pre class="mermaid">
graph TD
    A[Agent Function Runs] -->|1. @observe creates span| B[Span Created]
    B -->|Contains: model, tokens, tool, duration, status| C[Span Added to Batch Queue]
    C -->|2. Queue fills to 64 spans OR 5s timer| D{Batch Ready?}
    D -->|Yes| E[HTTP POST to Trace Collector]
    D -->|No, keep collecting| C
    E -->|3. Protobuf + gzip payload| F[Trace Collector Validates]
    F -->|Valid?| G{Schema OK + API Key Valid?}
    G -->|Yes| H[Written to Redis Stream]
    G -->|No| I[Rejected with Error Code]
    H -->|4. Three workers read in parallel| J[ClickHouse Writer]
    H -->|4. Parallel| K[Security Engine]
    H -->|4. Parallel| L[Cost Calculator]
    J -->|Batch INSERT 1000 rows| M[ClickHouse Database]
    K -->|Scans for threats| M
    L -->|Calculates dollar cost| M
    M -->|5. Dashboard queries| N[FastAPI REST API]
    N -->|JSON response in less than 500ms| O[React Dashboard Renders Timeline]
</pre>
</div>

<!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
<div class="diagram-section">
<h2><span class="badge">3</span> SDK Internals ‚Äî What Happens Inside @observe</h2>
<p>The SDK does 8 things in under 5 milliseconds without slowing down the agent</p>
<pre class="mermaid">
graph TD
    A[Developer Calls @observe Function] -->|Step 1| B[Decorator Wraps the Function]
    B -->|Step 2| C[Generate Unique trace_id and span_id]
    C -->|Step 3| D[Start Monotonic Clock]
    D -->|Step 4| E{Which Framework?}
    E -->|LangGraph| F[Hook into Node Execution]
    E -->|CrewAI| G[Hook into Task Pipeline]
    E -->|AutoGen| H[Hook into Message Flow]
    E -->|Custom| I[Wrap Function Directly]
    F --> J[Run the Actual Function]
    G --> J
    H --> J
    I --> J
    J -->|Step 5| K[Stop Clock - Record Duration]
    K -->|Step 6| L[Capture: Model, Tokens, Tool, Memory, Status]
    L -->|Step 7| M{Contains PII?}
    M -->|Yes| N[Scrub: SSN, Email, Phone, Credit Card]
    M -->|No| O[Span is Clean]
    N --> O
    O -->|Step 8| P[Add Span to Ring Buffer]
    P -->|Async, Non-Blocking| Q[Background Thread Handles Export]
    Q -->|Batch fills up| R[Send to Collector via HTTP]
    R -->|If collector down| S{Collector Available?}
    S -->|Yes| T[Delivered Successfully]
    S -->|No| U[Save to Local SQLite Fallback]
    U -->|When collector returns| V[Resend All Buffered Spans]
</pre>
</div>

<!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
<div class="diagram-section">
<h2><span class="badge">4</span> Storage Layer ‚Äî Redis + ClickHouse + 3 Workers</h2>
<p>Redis acts as a highway. Three workers drive on it simultaneously, each doing a different job.</p>
<pre class="mermaid">
graph TD
    A[Trace Collector] -->|XADD command| B[Redis Stream: spans.ingest]
    B -->|Consumer Group 1| C[ClickHouse Writer]
    B -->|Consumer Group 2| D[Security Engine]
    B -->|Consumer Group 3| E[Cost Calculator]

    C -->|Batches 1000 spans| F[INSERT into spans table]
    D -->|Scans each span| G{Threat Found?}
    G -->|Yes| H[INSERT into security_alerts table]
    G -->|No| I[Span is safe - skip]
    E -->|Extracts token count + model| J[Lookup price per token]
    J --> K[INSERT into cost_metrics table]

    F --> L[ClickHouse Database]
    H --> L
    K --> L

    L --> M{How Old is the Data?}
    M -->|Less than 7 days| N[Hot Storage - Fast SSD]
    M -->|7 to 90 days| O[Cold Storage - Compressed]
    M -->|Over 90 days| P[Auto-Deleted by TTL Policy]

    D -->|If threat found| Q[Also Push to alerts.live Stream]
    Q -->|WebSocket picks up| R[Dashboard Shows Red Alert Instantly]
</pre>
</div>

<!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
<div class="diagram-section">
<h2><span class="badge">5</span> Security Engine ‚Äî The Shield</h2>
<p>Every single span is scanned for 3 threat types before being stored</p>
<pre class="mermaid">
graph TD
    A[Span Arrives from Redis] -->|Scan begins| B{Check 1: Prompt Injection?}
    B -->|Look for| C[ignore previous instructions]
    B -->|Look for| D[you are now a different AI]
    B -->|Look for| E[system prompt override attempts]
    C --> F{Injection Detected?}
    D --> F
    E --> F

    A -->|Parallel scan| G{Check 2: PII Leak?}
    G -->|Pattern match| H[SSN: XXX-XX-XXXX]
    G -->|Pattern match| I[Email: user@domain.com]
    G -->|Pattern match| J[Credit Card: 4XXX-XXXX-XXXX]
    H --> K{PII Found?}
    I --> K
    J --> K

    A -->|Parallel scan| L{Check 3: Anomaly?}
    L -->|Detect| M[Same call repeated 50+ times]
    L -->|Detect| N[Token count exploding]
    L -->|Detect| O[Chain of timeouts]
    M --> P{Anomaly Detected?}
    N --> P
    O --> P

    F -->|No threat| Q((Safe))
    K -->|No PII| Q
    P -->|No anomaly| Q

    F -->|THREAT| R[Calculate Severity Score 0-100]
    K -->|PII FOUND| R
    P -->|ANOMALY| R

    R --> S{Score above 30?}
    S -->|Yes| T[Generate Alert Object]
    S -->|No| U[Log Warning Only]
    T --> V[Save to security_alerts in ClickHouse]
    T --> W[Push to alerts.live Redis Stream]
    T --> X[Dashboard Shows Immediate Red Alert]
    W --> Y[Optional: Webhook to Slack or PagerDuty]
</pre>
</div>

<!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
<div class="diagram-section">
<h2><span class="badge">6</span> Failure Recovery ‚Äî What Happens When Things Break</h2>
<p>Every component has a fallback. No spans are ever lost.</p>
<pre class="mermaid">
graph TD
    A{What Failed?} -->|Scenario 1| B[Collector is Down]
    A -->|Scenario 2| C[Redis is Down]
    A -->|Scenario 3| D[ClickHouse is Down]

    B --> E[SDK retries 3 times with backoff]
    E --> F{Still down?}
    F -->|Yes| G[Write spans to local SQLite file]
    F -->|No| H[Delivered on retry]
    G --> I[When collector returns: resend everything]
    I --> J((Zero spans lost))

    C --> K[Collector buffers in memory]
    K --> L[Max 10000 spans in bounded queue]
    L --> M{Queue full?}
    M -->|Yes| N[Return HTTP 429 to SDK]
    N --> O[SDK slows down sending]
    M -->|No| P[Keep buffering]
    K --> Q[Retry Redis every 5 seconds]
    Q --> R{Redis back?}
    R -->|Yes| S[Flush memory buffer to Redis]
    S --> J

    D --> T[ClickHouse Writer stops ACKing Redis]
    T --> U[Spans remain safe in Redis Stream]
    U --> V[Redis can hold ~1 million spans]
    V --> W[Thats ~2.7 hours of buffer at 100K per sec]
    W --> X{ClickHouse back?}
    X -->|Yes| Y[Writer replays all unACKed spans]
    Y --> J
</pre>
</div>

<!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
<div class="diagram-section">
<h2><span class="badge">7</span> Docker Deployment ‚Äî All Containers</h2>
<p>One command: docker compose up ‚Äî and the entire platform runs</p>
<pre class="mermaid">
graph TD
    A[Internet / Developer Browser] -->|Port 443 HTTPS| B[Nginx Reverse Proxy]
    B -->|Route: /api/*| C[FastAPI Server x2 replicas]
    B -->|Route: /| D[React Dashboard - Static Files]
    B -->|Route: /v1/traces| E[Trace Collector x2 replicas]

    E -->|XADD| F[Redis Container - Port 6379]
    F -->|Consumer| G[ClickHouse Writer Container]
    F -->|Consumer| H[Security Engine Container]
    F -->|Consumer| I[Cost Calculator Container]

    G -->|INSERT| J[ClickHouse Container - Port 8123]
    H -->|INSERT| J
    I -->|INSERT| J
    C -->|SELECT| J
    C -->|XREAD live| F

    J --- K[Volume: ch-data - Persistent Storage]
    F --- L[Volume: redis-data - AOF Persistence]
    B --- M[Volume: nginx-certs - TLS Certificates]

    N[docker-compose.yml] -->|Orchestrates all of the above| O((Single Command Deploy))
</pre>
</div>

<!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
<div class="diagram-section">
<h2><span class="badge">8</span> Scaling Evolution ‚Äî Dev ‚Üí Team ‚Üí Production</h2>
<p>Start tiny, grow huge. Same SDK, swap the backend.</p>
<pre class="mermaid">
graph TD
    subgraph STAGE1[Stage 1: Solo Developer - 0 to 10 spans per sec]
        S1A[SDK with @observe] -->|Saves locally| S1B[SQLite File on Disk]
        S1B -->|View in| S1C[CLI Terminal Viewer]
        S1C -->|Cost| S1D[FREE - No Server Needed]
    end

    subgraph STAGE2[Stage 2: Small Team - 10 to 1K spans per sec]
        S2A[SDK with @observe] -->|HTTP POST| S2B[FastAPI Server - Single Instance]
        S2B -->|Stores in| S2C[SQLite on Server]
        S2B -->|Serves| S2D[React Dashboard in Browser]
        S2D -->|Cost| S2E[20 dollars per month VPS]
    end

    subgraph STAGE3[Stage 3: Production - 1K to 100K spans per sec]
        S3A[SDK with @observe] -->|OTLP over HTTP| S3B[Load Balancer]
        S3B --> S3C[Collector x2]
        S3C --> S3D[Redis Streams]
        S3D --> S3E[ClickHouse Writer]
        S3D --> S3F[Security Engine]
        S3D --> S3G[Cost Calculator]
        S3E --> S3H[ClickHouse Cluster]
        S3F --> S3H
        S3G --> S3H
        S3H --> S3I[FastAPI x2]
        S3I --> S3J[React Dashboard + CDN]
        S3J -->|Cost| S3K[200 to 500 dollars per month]
    end

    STAGE1 -->|Add a server + dashboard| STAGE2
    STAGE2 -->|Add Redis + ClickHouse + workers| STAGE3
</pre>
</div>

</body>
</html>
